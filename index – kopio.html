<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <title>River Crossing â€” 8Ã—6</title>
  <link rel="apple-touch-icon" href="./icon-180.png">
  <style>
:root{
  --bg:#0b1021; --ink:#e5e7eb; --muted:#94a3b8;
  --bank:#0f172a; --water:#0b132a;
  /* lankut: 2 = keltainen, 3 = violetti, 4+ = vihreÃ¤ */
  --plank1:#facc15;  /* 2-yksikÃ¶n */
  --plank2:#c4b5fd;  /* 3-yksikÃ¶n */
  --plank3:#86efac;  /* 4+ */
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
html,body{height:100%;width:100%;margin:0;padding:0;}
body{
  background:var(--bg);color:var(--ink);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,sans-serif;
  display:grid;grid-template-rows:auto auto 1fr;align-items:start;justify-items:center;
  gap:clamp(4px, 1.5vh, 12px);
  padding:clamp(4px, 2vh, 8px) clamp(4px, 2vw, 12px) clamp(4px, 2vh, 12px);
  padding-top:max(env(safe-area-inset-top), clamp(4px, 2vh, 8px));
  padding-bottom:max(env(safe-area-inset-bottom), clamp(4px, 2vh, 8px));
  min-height:100vh;overflow-x:hidden;
}
h1{margin:4px 0;font-size:clamp(16px, 5vw, 20px);font-weight:700;}
.panel{
  width:min(95vw, 100%);background:#0b1021;border:1px solid #1f2937;border-radius:12px;
  box-shadow:0 6px 20px #00000055;padding:8px 10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;
}
.panel .left{display:flex;gap:6px;align-items:center;flex-wrap:wrap;justify-content:center;}
.panel .block{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
.panel button{
  appearance:none;border:1px solid #334155;background:#111827;color:var(--ink);
  padding:6px 8px;border-radius:8px;cursor:pointer;font-size:clamp(12px, 3vw, 14px);font-weight:500;white-space:nowrap;flex-shrink:0;
}
.panel button:active{opacity:.7;}
.panel button:disabled{opacity:.5;cursor:not-allowed;}
.panel small, .panel label{color:var(--muted);font-size:clamp(11px, 2.5vw, 13px);}
.panel input[type=range]{width:160px; accent-color:#22d3ee;}
.wrap{
  width:min(95vw, 100%);max-width:560px;
  aspect-ratio: 6 / 8; /* 8Ã—6: leveys 6, korkeus 8 */
  position:relative; display:flex;align-items:center;justify-content:center;
}
svg{
  width:100%;height:100%;display:block;border-radius:16px;border:1px solid #1f2937;
  background:#0b1021;
}
@media (max-width:480px) {
  body{gap:6px;padding:max(env(safe-area-inset-top),6px) 6px max(env(safe-area-inset-bottom),6px);}
  h1{margin:2px 0;}
  .panel{padding:6px 8px;gap:6px;border-radius:10px;}
  .panel button{padding:5px 7px;border-radius:7px;}
}
@media (min-width:768px) {
  body{gap:12px;padding:max(env(safe-area-inset-top),14px) 12px max(env(safe-area-inset-bottom),14px);}
  .panel{width:min(980px,95vw);padding:10px 12px;gap:12px;justify-content:space-between;}
  .panel .left{justify-content:flex-start;}
  .wrap{width:min(980px,95vw);}
}
@media (orientation:landscape) and (max-height:600px) {
  body{
    grid-template-rows:auto auto 1fr;
    gap:clamp(2px, 1vh, 8px);
    padding:max(env(safe-area-inset-top), 2px) clamp(4px, 2vw, 12px) max(env(safe-area-inset-bottom), 2px);
  }
  h1{margin:0;font-size:clamp(14px, 2.5vh, 18px);}
  .panel{
    padding:clamp(4px, 0.8vh, 8px) clamp(6px, 1.5vw, 10px);
    gap:clamp(4px, 1vw, 8px);
    width:min(95vw, 100%);
  }
  .panel button{padding:clamp(3px, 0.7vh, 6px) clamp(6px, 1vw, 8px);font-size:clamp(11px, 1.8vh, 13px);}
  .wrap{width:95vw;max-width:none;aspect-ratio: 6 / 8;}
}
  </style>
</head>
<body>
  <h1 id="title">River Crossing â€” 8Ã—6</h1>
  <div class="panel">
    <div class="left block">
      <button id="prev">Edellinen</button>
      <button id="next">Seuraava</button>
      <button id="reset">Palauta alku</button>
      <span id="meta"><small></small></span>
      <small>Siirrot: <b id="moves">0</b></small>
    </div>
    <div class="left block">
      <button id="solveBtn">NÃ¤ytÃ¤ ratkaisu</button>
      <label for="speed">Nopeus</label>
      <input id="speed" type="range" min="150" max="2000" step="50" value="700" />
      <small id="speedVal">700 ms</small>
    </div>
  </div>

  <div class="wrap">
    <svg id="board" viewBox="0 0 560 768" xmlns="http://www.w3.org/2000/svg" aria-label="pelilauta"></svg>
  </div>

<script>
/* ===== PWA manifest + SW (yhteen tiedostoon) ===== */
(function(){
  const manifest = {
    name: "River Crossing 8Ã—6",
    short_name: "Crossing",
    start_url: "./",
    display: "standalone",
    icons: [
      { src: "./icon-192.png", sizes: "192x192", type: "image/png", purpose: "any maskable" },
      { src: "./icon-512.png", sizes: "512x512", type: "image/png", purpose: "any maskable" }
    ]
  };
  const blob = new Blob([JSON.stringify(manifest)], {type:'application/json'});
  const link = document.createElement('link');
  link.rel = 'manifest'; link.href = URL.createObjectURL(blob);
  document.head.appendChild(link);

  if ('serviceWorker' in navigator && !location.href.startsWith('blob:') && !location.href.startsWith('data:')) {
    const swCode =
`self.addEventListener('install',e=>{self.skipWaiting();e.waitUntil(caches.open('rc8x6-v2').then(c=>c.addAll(['./','./puzzles_8x6.json'])))});
self.addEventListener('activate',e=>self.clients.claim());
self.addEventListener('fetch',e=>{e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)))})`;
    const swBlob = new Blob([swCode], {type:'text/javascript'});
    const swUrl = URL.createObjectURL(swBlob);
    navigator.serviceWorker.register(swUrl).catch(()=>{});
  }
})();
</script>

<script>
/* ===== perus ===== */
const CELL=64, W=6, H=6;  // leveys 6, vesirivejÃ¤ 6 (8-2)
const board=document.getElementById('board');
const metaEl=document.getElementById('meta').firstElementChild;
const movesEl=document.getElementById('moves');
const speedRange=document.getElementById('speed');
const speedVal=document.getElementById('speedVal');

const state={
  start:{side:'bottom', col:0},
  goal:{side:'top', col:5},
  stumps:[],           // {x,y} â€“ myÃ¶s rannalla (y=-1 tai y=H)
  planks:[],           // {len,x,y,dir:'h'|'v'} â€“ x,y=min-pÃ¤Ã¤
  hiker:{pos:'bank', row:H, col:0},
  carrying:0,
  moves:0, frozen:false, _snapshot:null, _meta:''
};

speedRange.addEventListener('input', ()=> speedVal.textContent = speedRange.value +' ms');
speedVal.textContent = speedRange.value +' ms';

/* ===== utilit ===== */
function svg(tag,attrs={}){const e=document.createElementNS('http://www.w3.org/2000/svg',tag);for(const k in attrs)e.setAttribute(k,attrs[k]);return e;}
function rect(x,y,w,h,a={}){return svg('rect',Object.assign({x,y,width:w,height:h},a));}
function line(x1,y1,x2,y2,a={}){return svg('line',Object.assign({x1,y1,x2,y2},a));}
function circle(cx,cy,r,a={}){return svg('circle',Object.assign({cx,cy,r},a));}

function stumpAt(x,y){
  if(state.stumps.some(s=>s.x===x && s.y===y)) return true;
  if(state.start){
    const sy = state.start.side==='top' ? -1 : H;
    if(x===state.start.col && y===sy) return true;
  }
  if(state.goal){
    const gy = state.goal.side==='top' ? -1 : H;
    if(x===state.goal.col && y===gy) return true;
  }
  return false;
}
function plankEndpoints(p){
  const dx=p.dir==='h'?1:0, dy=p.dir==='v'?1:0;
  return [{x:p.x,y:p.y},{x:p.x+dx*p.len,y:p.y+dy*p.len}];
}
function neighborsFrom(x,y){
  const adj=[];
  for(const p of state.planks){
    const [a,b]=plankEndpoints(p);
    if(a.x===x && a.y===y) adj.push(b);
    else if(b.x===x && b.y===y) adj.push(a);
  }
  return adj;
}
function reachedGoal(){
  const gy = state.goal.side === 'top' ? -1 : H;
  if (state.hiker.pos === 'stump' &&
      state.hiker.x === state.goal.col &&
      state.hiker.y === gy) return true;
  if (state.hiker.pos === 'bank' &&
      state.hiker.col === state.goal.col &&
      state.hiker.row === gy) return true;
  return false;
}

/* ===== sijoitusvalidointi ===== */
function segmentsOverlap(a1,a2,b1,b2){
  const L=Math.max(Math.min(a1,a2),Math.min(b1,b2));
  const R=Math.min(Math.max(a1,a2),Math.max(b1,b2));
  return (R-L)>0;
}
function crossesExisting(newP, list=state.planks){
  const [na,nb]=plankEndpoints(newP);
  for(const q of list){
    const [qa,qb]=plankEndpoints(q);
    if(newP.dir!==q.dir){
      const h=newP.dir==='h'?newP:q, v=newP.dir==='v'?newP:q;
      const [ha,hb]=plankEndpoints(h), [va,vb]=plankEndpoints(v);
      const x=va.x, y=ha.y;
      const onX = x>Math.min(ha.x,hb.x) && x<Math.max(ha.x,hb.x);
      const onY = y>Math.min(va.y,vb.y) && y<Math.max(va.y,vb.y);
      if(onX&&onY) return true;
    }else{
      if(newP.dir==='h' && qa.y===na.y && segmentsOverlap(na.x,nb.x,qa.x,qb.x)) return true;
      if(newP.dir==='v' && qa.x===na.x && segmentsOverlap(na.y,nb.y,qa.y,qb.y)) return true;
    }
  }
  return false;
}
function passesOverStump(newP){
  const [a,b]=plankEndpoints(newP);
  if(newP.dir==='h'){
    const y=a.y, x0=Math.min(a.x,b.x), x1=Math.max(a.x,b.x);
    for(let x=x0+1;x<=x1-1;x++) if(stumpAt(x,y)) return true;
  }else{
    const x=a.x, y0=Math.min(a.y,b.y), y1=Math.max(a.y,b.y);
    for(let y=y0+1;y<=y1-1;y++) if(stumpAt(x,y)) return true;
  }
  return false;
}
function canPlacePlank(len, sx,sy, tx,ty, useList=state.planks){
  const dx=tx-sx, dy=ty-sy;
  if(dx!==0 && dy!==0) return false;
  if(Math.abs(dx)+Math.abs(dy)!==len) return false;

  // rantasÃ¤Ã¤ntÃ¶: jos jompikumpi pÃ¤Ã¤ rannalla â†’ vain pysty; ei rantaâ€“ranta
  const aBank=(sy===-1||sy===H), bBank=(ty===-1||ty===H);
  if(aBank||bBank){
    if(sx!==tx) return false;
    if(aBank&&bBank) return false;
  }

  const newP={len,x:Math.min(sx,tx),y:Math.min(sy,ty),dir:(dy===0?'h':'v')};
  if(passesOverStump(newP)) return false;
  if(crossesExisting(newP, useList)) return false;
  return true;
}

/* ===== render ===== */
function render(){
  const pad=24, width=W*CELL+pad*2, height=(H+2)*CELL+pad*2; // (H+2) sisÃ¤ltÃ¤Ã¤ 2 pankkiriviÃ¤
  board.setAttribute('viewBox',`0 0 ${width} ${height}`);
  board.innerHTML='';

  // tausta
  const gBg=svg('g');
  gBg.appendChild(rect(pad, pad+CELL, W*CELL, H*CELL, {fill:'var(--water)', rx:16}));
  gBg.appendChild(rect(pad, pad, W*CELL, CELL, {fill:'var(--bank)', rx:12}));
  gBg.appendChild(rect(pad, pad+CELL*(H+1), W*CELL, CELL, {fill:'var(--bank)', rx:12}));
  board.appendChild(gBg);

  // ruudukko
  const grid=svg('g',{stroke:'#1f2937','stroke-width':2});
  for(let x=0;x<=W;x++) grid.appendChild(line(pad+x*CELL, pad+CELL, pad+x*CELL, pad+CELL*(H+1)));
  for(let y=1;y<=H+1;y++) grid.appendChild(line(pad, pad+y*CELL, pad+W*CELL, pad+y*CELL));
  board.appendChild(grid);

  // Lankut
  const gPlank=svg('g',{'stroke':'#00000022','stroke-width':1});
  for(const p of state.planks){
    const [a,b]=plankEndpoints(p);
    const x1=pad+a.x*CELL+CELL/2, y1=pad+(a.y+1)*CELL+CELL/2;
    const x2=pad+b.x*CELL+CELL/2, y2=pad+(b.y+1)*CELL+CELL/2;
    const len=Math.hypot(x2-x1,y2-y1), ang=Math.atan2(y2-y1,x2-x1)*180/Math.PI;
    const g=svg('g',{transform:`translate(${x1} ${y1}) rotate(${ang})`});
    const fill = (p.len===2)?'var(--plank1)' : (p.len===3)?'var(--plank2)' : 'var(--plank3)';
    g.appendChild(svg('rect',{x:0,y:-10,width:len,height:20,fill,rx:10,opacity:.95,filter:'saturate(1.05)'}));
    g.appendChild(circle(0,0,6,{fill:'#00000033'}));
    g.appendChild(circle(len,0,6,{fill:'#00000033'}));
    g.style.cursor='pointer';
    g.addEventListener('click',()=>onPlankClick(p));
    gPlank.appendChild(g);
  }
  board.appendChild(gPlank);

  // S/G ja hot-alueet
  const gMarks=svg('g');
  const startX=pad+state.start.col*CELL+CELL/2;
  const startY=(state.start.side==='top')? (pad+CELL/2):(pad+(H+1.5)*CELL);
  const goalX =pad+state.goal.col*CELL+CELL/2;
  const goalY =(state.goal.side==='top')? (pad+CELL/2):(pad+(H+1.5)*CELL);

  const sDot=circle(startX,startY,10,{fill:'#111827',stroke:'#16a34a','stroke-width':3});
  sDot.style.cursor='pointer';
  sDot.addEventListener('click',()=>onStumpClick(state.start.col, state.start.side==='top'?-1:H));
  gMarks.appendChild(sDot);

  const gDot=circle(goalX,goalY,10,{fill:'#111827',stroke:'#dc2626','stroke-width':3});
  gDot.style.cursor='pointer';
  gDot.addEventListener('click',()=>onStumpClick(state.goal.col, state.goal.side==='top'?-1:H));
  gMarks.appendChild(gDot);

  board.appendChild(gMarks);

  // Tolpat
  const gSt=svg('g');
  for(const s of state.stumps){
    const cx=pad+s.x*CELL+CELL/2, cy=pad+(s.y+1)*CELL+CELL/2;
    const dot=circle(cx,cy,10,{fill:'#111827',stroke:'#e5e7eb','stroke-width':2});
    dot.style.cursor='pointer';
    dot.addEventListener('click',()=>onStumpClick(s.x,s.y));
    gSt.appendChild(dot);
  }
  board.appendChild(gSt);

  // Hiker
  const gH=svg('g');
  if(state.hiker.pos==='stump'){
    const cx=pad+state.hiker.x*CELL+CELL/2;
    const cy=pad+(state.hiker.y+1)*CELL+CELL/2;
    gH.appendChild(circle(cx,cy,16,{fill:'#38bdf8',stroke:'#083344','stroke-width':2}));
  }else{
    const y=state.hiker.row<0? pad+CELL/2: pad+(H+1.5)*CELL;
    const cx=pad+state.hiker.col*CELL+CELL/2;
    gH.appendChild(circle(cx,y,16,{fill:'#38bdf8',stroke:'#083344','stroke-width':2}));
  }
  board.appendChild(gH);

  metaEl.textContent=state._meta||'';
  movesEl.textContent=state.moves;
}

/* ===== interaktio ===== */
function onStumpClick(x,y){
  if(state.frozen) return;

  // 1) NOSTO â€“ jos seisot tÃ¤llÃ¤ tolpalla
  if(state.carrying===0 && state.hiker.pos==='stump' && state.hiker.x===x && state.hiker.y===y){
    for(let i=0;i<state.planks.length;i++){
      const p=state.planks[i], [a,b]=plankEndpoints(p);
      if((a.x===x&&a.y===y)||(b.x===x&&b.y===y)){
        state.carrying=p.len; state.planks.splice(i,1); render(); return;
      }
    }
  }

  // 2) LASKU â€“ kantolankku tÃ¤hÃ¤n tolppaan
  if(state.carrying && state.hiker.pos==='stump'){
    const sx=state.hiker.x, sy=state.hiker.y, len=state.carrying;
    const dx=x-sx, dy=y-sy;
    if((dx===0||dy===0) && Math.abs(dx)+Math.abs(dy)===len){
      // tarkista risteykset/lista ilman tulevaa lankkua (ok: kÃ¤ytetÃ¤Ã¤n oletuslistaa)
      if(canPlacePlank(len, sx,sy, x,y)){
        state.planks.push({len, x:Math.min(sx,x), y:Math.min(sy,y), dir:(dy===0?'h':'v')});
        state.carrying=0; state.moves++; render(); return;
      }
    }
  }

  // 3) KÃ„VELY pankista stumpille
  if(state.hiker.pos==='bank'){
    const adj=neighborsFrom(state.hiker.col, state.hiker.row);
    if(adj.some(p=>p.x===x&&p.y===y)){
      state.hiker = { pos:'stump', x, y };
      render(); checkIfGoalReached(); return;
    }
  }else{
    // 4) KÃ„VELY stumpilta stumpille
    const adj=neighborsFrom(state.hiker.x, state.hiker.y);
    if(adj.some(p=>p.x===x&&p.y===y)){
      state.hiker={pos:'stump',x,y};
      render(); checkIfGoalReached(); return;
    }
  }
}
function onPlankClick(p){
  if(state.frozen||state.carrying) return;
  const [a,b]=plankEndpoints(p);
  if(state.hiker.pos==='stump' && ((state.hiker.x===a.x&&state.hiker.y===a.y)||(state.hiker.x===b.x&&state.hiker.y===b.y))){
    for(let i=0;i<state.planks.length;i++){
      if(state.planks[i]===p){ state.carrying=p.len; state.planks.splice(i,1); render(); return; }
    }
  }
}

function checkIfGoalReached() {
  if (reachedGoal()) showWinDialog();
}

/* ====== SOLVER (BFS) + ANIMAATIO ====== */
/* Labelointi editorin logiikalla (y=-1 top â†’ 0..5, y=H bottom â†’ 6..11, vesialue kirjaimet) */
function lettersFromIndex(n){
  let s=''; n = n|0;
  while(true){
    s = String.fromCharCode(65 + (n % 26)) + s;
    n = Math.floor(n / 26) - 1;
    if(n < 0) break;
  }
  return s;
}
function labelFor(x,y){
  if(y===-1) return String(x);       // ylÃ¤ranta 0..5
  if(y===H)  return String(6 + x);   // alaranta 6..11
  const idx = y*W + x;               // 0..(W*H-1)
  return lettersFromIndex(idx);
}
function allPolesForSolve(){
  const P=[];
  // start & goal
  P.push({x:state.start.col, y: state.start.side==='top'?-1:H});
  P.push({x:state.goal.col,  y: state.goal.side==='top' ?-1:H});
  // stumps (uniikit)
  const seen=new Set();
  for(const s of state.stumps){
    const k=`${s.x},${s.y}`; if(!seen.has(k)){ seen.add(k); P.push({x:s.x,y:s.y}); }
  }
  return P;
}
function buildAdj(planks){
  const adj = new Map();
  function add(u,v){ if(!adj.has(u)) adj.set(u,[]); adj.get(u).push(v); }
  for(const p of planks){
    const [a,b]=plankEndpoints(p);
    const A=labelFor(a.x,a.y), B=labelFor(b.x,b.y);
    add(A,B); add(B,A);
  }
  return adj;
}
function reachableFromLabel(lbl, planks){
  const adj=buildAdj(planks), seen=new Set();
  if(!lbl) return seen;
  const q=[lbl]; seen.add(lbl);
  while(q.length){
    const x=q.shift();
    for(const y of (adj.get(x)||[])) if(!seen.has(y)){ seen.add(y); q.push(y); }
  }
  return seen;
}
function serializeState(planks, who){
  const keys=planks.map(p=>{
    const [a,b]=plankEndpoints(p);
    const A=labelFor(a.x,a.y), B=labelFor(b.x,b.y);
    return (A<B)?`${A}|${B}`:`${B}|${A}`;
  }).sort();
  return who+'#'+keys.join(',');
}
function lineClearBetween(sx,sy, tx,ty){
  const stepX = Math.sign(tx-sx), stepY = Math.sign(ty-sy);
  let x=sx+stepX, y=sy+stepY;
  while(!(x===tx && y===ty)){
    if(stumpAt(x,y)) return false;
    x+=stepX; y+=stepY;
  }
  return true;
}
function validSpansOfLength(len, occupiedKeys, otherPlanks){
  const P=allPolesForSolve(), spans=[];
  for(let i=0;i<P.length;i++){
    for(let j=i+1;j<P.length;j++){
      const a=P[i], b=P[j];
      const dx=Math.abs(a.x-b.x), dy=Math.abs(a.y-b.y);
      if(dx && dy) continue;                // vain suorat
      if(dx+dy!==len) continue;             // pituus
      // rantasÃ¤Ã¤ntÃ¶
      const aBank=(a.y===-1||a.y===H), bBank=(b.y===-1||b.y===H);
      if(aBank || bBank){
        if(a.x!==b.x) continue;             // pystysuora
        if(aBank && bBank) continue;        // ei rantaâ€“ranta
      }
      // varattu?
      const A=labelFor(a.x,a.y), B=labelFor(b.x,b.y);
      const key = (A<B)?`${A}|${B}`:`${B}|${A}`;
      if(occupiedKeys && occupiedKeys.has(key)) continue;

      // ei vÃ¤litolppaa
      if(!lineClearBetween(a.x,a.y,b.x,b.y)) continue;

      // ei risteystÃ¤/limitystÃ¤
      const dir = (dy===0)?'h':'v';
      const cand = {len, x:Math.min(a.x,b.x), y:Math.min(a.y,b.y), dir};
      if(crossesExisting(cand, otherPlanks)) continue;

      spans.push({a,b,key,txt:(A<B)?A+B:B+A});
    }
  }
  return spans;
}
function solveBFS(){
  // muodosta aloitusplankit
  const initPlanks = state.planks.map(p=>({len:p.len,x:p.x,y:p.y,dir:p.dir}));
  const startLbl = labelFor(state.start.col, state.start.side==='top'?-1:H);
  const goalLbl  = labelFor(state.goal.col,  state.goal.side==='top' ?-1:H);

  if(reachableFromLabel(startLbl, initPlanks).has(goalLbl)){
    return {moves:[], depth:0}; // jo ratkaistu
  }

  const MAX_STATES=200000;
  const startKey=serializeState(initPlanks, startLbl);
  const seen=new Set([startKey]);
  const Q=[{planks:initPlanks, who:startLbl, depth:0}];
  const parent=new Map(); // key â†’ {prev, move}

  while(Q.length){
    const cur=Q.shift();
    const curKey=serializeState(cur.planks, cur.who);

    // maali?
    if(reachableFromLabel(cur.who, cur.planks).has(goalLbl)){
      // pura sekvenssi
      const seq=[]; let k=curKey;
      while(k!==startKey){ const p=parent.get(k); if(!p) break; seq.push(p.move); k=p.prev; }
      seq.reverse();
      return {moves:seq, depth:seq.length};
    }

    // generoidaan siirrot
    const occupied = new Set(cur.planks.map(p=>{
      const [a,b]=plankEndpoints(p);
      const A=labelFor(a.x,a.y), B=labelFor(b.x,b.y);
      return (A<B)?`${A}|${B}`:`${B}|${A}`;
    }));
    const reachNow = reachableFromLabel(cur.who, cur.planks);

    for(let i=0;i<cur.planks.length;i++){
      const p=cur.planks[i];
      const [a,b]=plankEndpoints(p);
      const A=labelFor(a.x,a.y), B=labelFor(b.x,b.y);
      const pickupEnd = [];
      if(reachNow.has(A)) pickupEnd.push(A);
      if(reachNow.has(B)) pickupEnd.push(B);
      if(pickupEnd.length===0) continue;

      const rest = cur.planks.filter((_,idx)=>idx!==i);
      const occMinus = new Set(occupied); occMinus.delete((A<B)?`${A}|${B}`:`${B}|${A}`);
      const candSpans = validSpansOfLength(p.len, occMinus, rest);

      for(const pick of pickupEnd){
        const reachCarry = reachableFromLabel(pick, rest);
        for(const cand of candSpans){
          const newA = labelFor(cand.a.x,cand.a.y), newB = labelFor(cand.b.x,cand.b.y);
          if(!reachCarry.has(newA) && !reachCarry.has(newB)) continue;

          const nxt = rest.slice();
          nxt.splice(i,0,{len:p.len,x:cand.a.x<cand.b.x?cand.a.x:cand.b.x,
                          y:cand.a.y<cand.b.y?cand.a.y:cand.b.y,
                          dir:(cand.a.y===cand.b.y?'h':'v')});
          const nxtWho = reachCarry.has(newA) ? newA : newB;
          const nxtKey = serializeState(nxt, nxtWho);
          if(seen.has(nxtKey)) continue;
          seen.add(nxtKey);

          const oldTxt = (A<B)?A+B:B+A;
          const moveTxt = `${oldTxt.toLowerCase()}-${cand.txt.toLowerCase()}`;
          parent.set(nxtKey, {prev:curKey, move:{
            fromLabelPair: oldTxt, toLabelPair: cand.txt,
            len: p.len,
            // sovitettu koordinaattimuoto animointia varten:
            from: {ax:a.x, ay:a.y, bx:b.x, by:b.y},
            to:   {ax:cand.a.x, ay:cand.a.y, bx:cand.b.x, by:cand.b.y}
          }});

          if(reachableFromLabel(nxtWho, nxt).has(goalLbl)){
            const seq=[parent.get(nxtKey).move]; let k=curKey;
            while(k!==startKey){ const pp=parent.get(k); if(!pp) break; seq.push(pp.move); k=pp.prev; }
            seq.reverse();
            return {moves:seq, depth:seq.length};
          }

          if(seen.size<MAX_STATES) Q.push({planks:nxt, who:nxtWho, depth:cur.depth+1});
        }
      }
    }
  }
  return null; // ei ratkea
}

/* Animaatio ratkaisusta */
let playing=false;
async function playSolution(){
  if(playing) return;
  // reset
  if(state._snapshot){
    const snap = JSON.parse(state._snapshot);
    Object.assign(state, snap);
    state._snapshot = JSON.stringify(snap); // pidetÃ¤Ã¤n nollatilanne
    render();
  }
  const sol = solveBFS();
  if(!sol){ metaEl.textContent='Ei ratkaisua'; return; }
  metaEl.textContent = `Ratkaisun pituus: ${sol.depth}`;
  if(sol.depth===0){ return; }

  playing=true; state.frozen=true;
  const delay = +speedRange.value;

  // kÃ¤ydÃ¤Ã¤n siirrot lÃ¤pi
  for(const mv of sol.moves){
    // etsitÃ¤Ã¤n plankki joka vastaa "from"-spania (koordinaattimielessÃ¤)
    const f = mv.from;
    const idx = state.planks.findIndex(pl=>{
      const [a,b]=plankEndpoints(pl);
      return (a.x===f.ax && a.y===f.ay && b.x===f.bx && b.y===f.by) ||
             (a.x===f.bx && a.y===f.by && b.x===f.ax && b.y===f.ay);
    });
    if(idx<0){
      // jos ei lÃ¶ydy, ratkaisu todennÃ¤kÃ¶isesti viittaa identtiseen span-avaimeen mutta plankki on siirtynyt; varmistetaan len-match
      // fallback: etsi vain pituuden perusteella mikÃ¤ on siirrettÃ¤vissÃ¤ ja tuottaa mv.to
      const id2 = state.planks.findIndex(pl=>{
        if(pl.len!==mv.len) return false;
        // voiko se siirtyÃ¤ mv.to:ksi muiden kanssa?
        const temp = state.planks.slice(); temp.splice(temp.indexOf(pl),1);
        return canPlacePlank(pl.len, mv.to.ax, mv.to.ay, mv.to.bx, mv.to.by, temp);
      });
      if(id2<0) continue;
      // poista ja aseta uuteen paikkaan
      const pick = state.planks[id2];
      state.planks.splice(id2,1);
      const len = pick.len;
      const dx = mv.to.bx - mv.to.ax, dy = mv.to.by - mv.to.ay;
      state.planks.push({len, x:Math.min(mv.to.ax,mv.to.bx), y:Math.min(mv.to.ay,mv.to.by), dir:(dy===0?'h':'v')});
    }else{
      const pick = state.planks[idx];
      state.planks.splice(idx,1);
      const len = pick.len;
      const dx = mv.to.bx - mv.to.ax, dy = mv.to.by - mv.to.ay;
      state.planks.push({len, x:Math.min(mv.to.ax,mv.to.bx), y:Math.min(mv.to.ay,mv.to.by), dir:(dy===0?'h':'v')});
    }
    state.moves++;
    render();
    await new Promise(r=>setTimeout(r, delay));
  }
  state.frozen=false; playing=false;
  checkIfGoalReached();
}

/* ===== puzzles ===== */
async function loadPuzzlesFromFile(){
  try{
    const resp=await fetch('./puzzles_8x6.json');
    const all=await resp.json();
    window._PUZZLES=all;
    let i=+localStorage.getItem('rc8x6_idx')||0;
    i=Math.max(0,Math.min(all.length-1,i));
    applyPuzzle(all[i],i,all.length);
  }catch(e){ console.error(e); state._meta='Puzzles-tiedoston lataus epÃ¤onnistui'; render(); }
}
function mapEditorToGame(p){
  if(!(p && p.cols===6 && p.rows===8)) throw new Error('VÃ¤Ã¤rÃ¤ koko (8Ã—6)');
  const toXY=(r,c)=> r===0?{x:c,y:-1} : r===7?{x:c,y:H} : {x:c,y:r-1};

  const s=toXY(p.start.r,p.start.c), g=toXY(p.goal.r,p.goal.c);
  const start={side:(s.y===-1?'top':'bottom'), col:s.x};
  const goal ={side:(g.y===-1?'top':'bottom'), col:g.x};

  const stumps=[]; const seen=new Set();
  (p.poles||[]).forEach(({r,c})=>{
    const {x,y}=toXY(r,c);
    const k=`${x},${y}`; if(!seen.has(k)){ seen.add(k); stumps.push({x,y}); }
  });

  const planks=[];
  (p.planks||[]).forEach(([r1,c1,r2,c2])=>{
    const a=toXY(r1,c1), b=toXY(r2,c2);
    const dx=b.x-a.x, dy=b.y-a.y;
    if(dx!==0 && dy!==0) return;
    const len=Math.abs(dx)+Math.abs(dy);
    planks.push({len, x:Math.min(a.x,b.x), y:Math.min(a.y,b.y), dir:(dy===0?'h':'v')});
  });

  return {start,goal,stumps,planks};
}
function applyPuzzle(p,idx,total){
  const m=mapEditorToGame(p);
  state.start=m.start; state.goal=m.goal;
  state.stumps=m.stumps.slice(); state.planks=m.planks.slice();
  state.hiker={pos:'bank', row:(state.start.side==='top'?-1:H), col:state.start.col};
  state.carrying=0; state.moves=0; state.frozen=false;
  state._meta=`Pulma ${idx+1}/${total}`;
  state._snapshot=JSON.stringify({start:state.start,goal:state.goal,stumps:state.stumps,planks:state.planks,hiker:state.hiker,carrying:0,moves:0,_meta:state._meta});
  render(); localStorage.setItem('rc8x6_idx', idx);
}

/* ===== nav ===== */
document.getElementById('prev').addEventListener('click',()=>{
  const all=window._PUZZLES||[]; if(!all.length) return;
  let i=(+localStorage.getItem('rc8x6_idx')||0)-1; if(i<0) i=all.length-1;
  applyPuzzle(all[i],i,all.length);
});
document.getElementById('next').addEventListener('click',()=>{
  const all=window._PUZZLES||[]; if(!all.length) return;
  let i=(+localStorage.getItem('rc8x6_idx')||0)+1; if(i>=all.length) i=0;
  applyPuzzle(all[i],i,all.length);
});
document.getElementById('reset').addEventListener('click',()=>{
  const s=state._snapshot; if(!s) return;
  Object.assign(state, JSON.parse(s)); state._snapshot=s; render();
});
document.getElementById('solveBtn').addEventListener('click', playSolution);

/* ===== responsiivinen korjaus (iPad) ===== */
function fixLandscapeLayout(){
  const wrap = document.querySelector('.wrap');
  if(!wrap) return;

  const h1 = document.querySelector('h1');
  const panel = document.querySelector('.panel');
  const body = document.body;

  const h1Height = h1?.offsetHeight || 0;
  const panelHeight = panel?.offsetHeight || 0;
  const paddingTop = parseInt(getComputedStyle(body).paddingTop);
  const paddingBottom = parseInt(getComputedStyle(body).paddingBottom);
  const gap = parseInt(getComputedStyle(body).gap);

  const totalReserved = h1Height + panelHeight + paddingTop + paddingBottom + gap * 2;
  const availableHeight = window.innerHeight - totalReserved;
  const maxWidth = wrap.offsetWidth;

  // SVG:n suhde = korkeus/leveys = (H+2)/W  â†’ 8Ã—6 â†’ 8/6
  const ratio = (H+2) / W;
  const targetHeight = Math.min(availableHeight, maxWidth * ratio);
  wrap.style.height = targetHeight + 'px';
}
window.addEventListener('orientationchange', () => setTimeout(fixLandscapeLayout, 100));
window.addEventListener('resize', fixLandscapeLayout);
fixLandscapeLayout();

/* ===== init ===== */
loadPuzzlesFromFile();
</script>

<!-- Loppudialogi -->
<div id="win-dialog" class="dialog hidden">
  <div class="dialog-content">
    <h2>Onneksi olkoon!</h2>
    <p>PÃ¤Ã¤sit maaliin ðŸŽ‰</p>
    <button id="close-dialog">OK</button>
  </div>
</div>

<style>
.dialog{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,0.5);
  z-index:1000;
}
.dialog.hidden{ display:none; }
.dialog-content{
  background:#fff; color:#111;
  padding:24px 32px; border-radius:12px;
  text-align:center; font-family:-apple-system, sans-serif;
  max-width:280px;
}
.dialog-content h2{ margin-top:0; }
.dialog-content button{
  margin-top:12px; padding:8px 20px; border:none;
  background:#0f172a; color:#fff; border-radius:6px; font-size:16px;
}
</style>

<!-- QR-koodi otsikkoon (iPad-kosketus avaa) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
<style>
  #qrOverlay{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.6);z-index:999;
  }
  #qrBox{
    background:#fff;padding:16px 20px;border-radius:12px;text-align:center;
    box-shadow:0 0 20px rgba(0,0,0,.4);
  }
  #qrBox canvas{width:180px;height:180px;}
  #qrBox p{margin:8px 0 0;font-size:14px;color:#222;}
</style>
<div id="qrOverlay">
  <div id="qrBox">
    <canvas id="qr"></canvas>
    <p>ymouse91.github.io/crossing/</p>
  </div>
</div>
<script>
const qr = new QRious({
  element: document.getElementById('qr'),
  value: 'https://ymouse91.github.io/crossing/',
  size: 180
});
const overlay = document.getElementById('qrOverlay');
const title = document.getElementById('title');
title.addEventListener('click', ()=>overlay.style.display='flex');
overlay.addEventListener('click', ()=>overlay.style.display='none');

document.getElementById('close-dialog').onclick = () => document.getElementById('win-dialog').classList.add('hidden');
</script>

</body>
</html>
