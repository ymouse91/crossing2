<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover,user-scalable=no" />
<title>River Crossing Editor (8×6) + Solver</title>
<style>
:root{--cell:72px;--gap:3px;--bank:#c8e7ff;--water:#a6dbff;--grid:#90caff;--pole:#222;--plank:#b8860b;}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;background:#eaf6ff;
display:flex;flex-direction:column;align-items:center;gap:12px;padding:20px;}
h2{margin:6px 0 2px;}
#controls,#loader{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center;}
button,select,input[type=file]{font-size:16px;padding:6px 10px;cursor:pointer;}

/* 8×6 ruudukko */
#board{position:relative;display:grid;grid-template-rows:repeat(8,var(--cell));
grid-template-columns:repeat(6,var(--cell));gap:var(--gap);border:2px solid #7fb7ff;border-radius:8px;
background:var(--water);touch-action:manipulation;}

.cell{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;
position:relative;border:1px solid #bcdfff;cursor:pointer;}
.bank{background:var(--bank);border-color:#aacfee;}
.water{background:var(--grid);}
.cell.pole::after{content:'';width:18px;height:18px;border-radius:50%;background:var(--pole);
position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:2;}

.badge{position:absolute;left:50%;top:50%;width:28px;height:28px;border-radius:50%;
transform:translate(-50%,-50%);display:flex;align-items:center;justify-content:center;
font:800 14px/1 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;color:#fff;
box-shadow:0 1px 3px rgba(0,0,0,.25);pointer-events:none;z-index:3;}
.start-badge{background:#16a34a;} .goal-badge{background:#dc2626;}

.plank{position:absolute;height:14px;border-radius:7px;background:var(--plank);
transform-origin:left center;box-shadow:0 1px 3px rgba(0,0,0,.25);z-index:1;pointer-events:none;}

.mode-indicator{font-size:13px;color:#334155;opacity:.8;padding:2px 8px;background:#fff;border:1px solid #cbd5e1;border-radius:999px;}
.active{outline:2px solid #0d6efd;outline-offset:2px;}
.selPole{box-shadow:inset 0 0 0 3px #ef4444;}
.small{font-size:13px;opacity:.75;}
.toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#0f172a;color:#fff;
padding:8px 12px;border-radius:8px;font-size:14px;opacity:.95;}

/* vas. ylänurkan ruutulappu */
.mini{position:absolute;left:6px;top:4px;font-size:12px;line-height:1;color:#0f172a;opacity:.9;
background:#ffffffc7;border:1px solid #cbd5e1;border-radius:6px;padding:1px 5px;pointer-events:none;}

#solveOut{max-width:min(720px,90vw);white-space:pre-wrap;background:#fff;border:1px solid #cbd5e1;border-radius:10px;padding:10px;}
.status{font-size:12px;color:#334155;background:#fff;border:1px solid #cbd5e1;border-radius:999px;padding:2px 8px;}
.row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center;}
</style>
</head>
<body>
<h2>River Crossing -asettelueditori (8×6)</h2>

<div id="controls" class="row">
  <span class="mode-indicator">Tila: <b id="modeLbl">Tolpat</b></span>
  <button id="modePole" class="active">Tolpat</button>
  <button id="modeStart">Start</button>
  <button id="modeGoal">Goal</button>
  <button id="modePlank">Lankku</button>
  <button id="clearBtn">Tyhjennä</button>
</div>

<div id="loader" class="row">
  <label>Valitse JSON-tiedosto:
    <input id="fileInput" type="file" accept="application/json" />
  </label>
  <label>Avaa tallenne:
    <select id="puzzleSel"></select>
  </label>
  <button id="openSelected">Avaa laudalle</button>
  <button id="deleteSelected">Poista valittu</button>
  <span id="curStatus" class="status">Nykyinen: (uusi, ei listassa)</span>
</div>

<div class="row">
  <button id="saveChanges" style="border-color:#0ea5e9;background:#e0f2fe">Tallenna muutokset valittuun</button>
  <button id="saveNew" style="border-color:#16a34a;background:#dcfce7">Tallenna nykyinen uutena</button>
  <button id="moveUp">▲ Siirrä ylös</button>
  <button id="moveDown">▼ Siirrä alas</button>
  <button id="saveBtn" title="Vie koko lista tiedostoksi">Lataa JSON-tiedosto</button>
</div>

<div class="row">
  <button id="solveBtn" style="background:#0d6efd;color:#fff;border-color:#0b5ed7;">Tarkista ratkeavuus</button>
</div>

<div id="board"></div>
<div class="small">Säännöt: Start/Goal vain rannoilla. Lankut suoria; rannalta aina pystysuora.</div>

<h3>Solverin tulos</h3>
<pre id="solveOut">–</pre>

<script>
/* --- Perusmitat 8×6 --- */
const ROWS=8, COLS=6, LS_KEY='rc_puzzles_8x6';

const board=document.getElementById('board'),modeLbl=document.getElementById('modeLbl'),
fileInput=document.getElementById('fileInput'),
puzzleSel=document.getElementById('puzzleSel'),deleteBtn=document.getElementById('deleteSelected'),
openBtn=document.getElementById('openSelected'),saveBtn=document.getElementById('saveBtn'),
clearBtn=document.getElementById('clearBtn'),solveBtn=document.getElementById('solveBtn'),
solveOut=document.getElementById('solveOut'),
saveChanges=document.getElementById('saveChanges'),saveNew=document.getElementById('saveNew'),
moveUp=document.getElementById('moveUp'),moveDown=document.getElementById('moveDown'),
curStatus=document.getElementById('curStatus');

let mode='pole',uid=1,firstSel=null;
let currentIdx = -1; // indeksi localStorage-listassa; -1 = uusi luonnos

const state={poles:[],planks:[],start:null,goal:null,plankEls:new Map()};

/* ---------- UI helpers ---------- */
function toast(m,s=1500){const t=document.createElement('div');t.className='toast';t.textContent=m;
document.body.appendChild(t);setTimeout(()=>t.remove(),s);}
function setStatus(){
  curStatus.textContent = (currentIdx>=0) ? `Nykyinen: #${currentIdx+1}` : 'Nykyinen: (uusi, ei listassa)';
}

/* ---------- Labelointi (A..Z, AA.. jne.) ---------- */
function lettersFromIndex(n){
  // Excel-tyylinen A, B, ..., Z, AA, AB, ...
  let s=''; n = n|0;
  while(true){
    s = String.fromCharCode(65 + (n % 26)) + s;
    n = Math.floor(n / 26) - 1;
    if(n < 0) break;
  }
  return s;
}
function labelForCell(r,c){
  if(r===0){ return String(c); }             // yläranta 0..(COLS-1)
  if(r===ROWS-1){ return String(COLS + c); } // alaranta COLS..(2*COLS-1)
  const idx=(r-1)*COLS + c;                  // vesirivit: 0..( (ROWS-2)*COLS - 1 )
  return lettersFromIndex(idx);              // A..Z, AA, AB, ...
}
function addMiniLabel(cell,r,c){
  const d=document.createElement('div');d.className='mini';d.textContent=labelForCell(r,c);
  cell.appendChild(d);
}

/* ---------- Board ---------- */
function buildBoard(){
  board.innerHTML='';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const d=document.createElement('div');
      d.className='cell '+((r===0||r===ROWS-1)?'bank':'water');
      d.dataset.r=r;d.dataset.c=c;
      addMiniLabel(d,r,c);
      board.appendChild(d);
    }
  }
}
buildBoard();
function getCell(r,c){return board.children[r*COLS+c];}
function isBank(r){return r===0||r===ROWS-1;}
function isSame(a,b){return a&&b&&a.r===b.r&&a.c===b.c;}
function clearSel(){document.querySelectorAll('.selPole').forEach(e=>e.classList.remove('selPole'));firstSel=null;}

/* ---------- Modes ---------- */
function setMode(m){
  mode=m;modeLbl.textContent={pole:'Tolpat',start:'Start',goal:'Goal',plank:'Lankku'}[m];
  document.querySelectorAll('#modePole,#modeStart,#modeGoal,#modePlank').forEach(b=>b.classList.remove('active'));
  ({pole:modePole,start:modeStart,goal:modeGoal,plank:modePlank}[m]).classList.add('active');
  clearSel();
}
modePole.onclick=()=>setMode('pole');modeStart.onclick=()=>setMode('start');
modeGoal.onclick=()=>setMode('goal');modePlank.onclick=()=>setMode('plank');
board.addEventListener('dblclick',()=>setMode('plank'));

/* ---------- Badges ---------- */
function ensureBadge(r,c,t){
  const cell=getCell(r,c);
  cell.querySelectorAll('.badge').forEach(b=>b.remove());
  const b=document.createElement('div');b.className='badge '+(t==='start'?'start-badge':'goal-badge');
  b.textContent=t==='start'?'S':'G';cell.appendChild(b);
}
function clearBadge(p){if(!p)return;getCell(p.r,p.c).querySelectorAll('.badge').forEach(b=>b.remove());}

/* ---------- Start/Goal/Pole ---------- */
function setStart(r,c){
  if(!isBank(r)){toast('Start vain rannoille');return;}
  getCell(r,c).classList.remove('pole');
  state.poles=state.poles.filter(p=>!(p.r===r&&p.c===c));
  clearBadge(state.start);state.start={r,c};ensureBadge(r,c,'start');
}
function setGoal(r,c){
  if(!isBank(r)){toast('Goal vain rannoille');return;}
  getCell(r,c).classList.remove('pole');
  state.poles=state.poles.filter(p=>!(p.r===r&&p.c===c));
  clearBadge(state.goal);state.goal={r,c};ensureBadge(r,c,'goal');
}

function togglePole(r, c, cell) {
  // sallitaan tolpat myös rannoilla; korvaa S/G jos päälle
  if (state.start && state.start.r === r && state.start.c === c) { clearBadge(state.start); state.start = null; }
  if (state.goal && state.goal.r === r && state.goal.c === c)   { clearBadge(state.goal);  state.goal  = null; }
  const i = state.poles.findIndex(p => p.r === r && p.c === c);
  if (i >= 0) { state.poles.splice(i, 1); cell.classList.remove('pole'); }
  else { state.poles.push({ r, c }); cell.classList.add('pole'); }
}

/* ---------- Planks ---------- */
function cellCenter(r,c){
  const cb=getCell(r,c).getBoundingClientRect(),bb=board.getBoundingClientRect();
  return{x:(cb.left-bb.left)+cb.width/2,y:(cb.top-bb.top)+cb.height/2};
}
function drawPlank(p){
  const A=cellCenter(p.r1,p.c1),B=cellCenter(p.r2,p.c2),dx=B.x-A.x,dy=B.y-A.y,len=Math.hypot(dx,dy);
  const el=document.createElement('div');el.className='plank';el.dataset.pid=p.id;
  el.style.width=len+'px';el.style.left=A.x+'px';el.style.top=A.y+'px';
  el.style.transform=`translate(-0%,-50%) rotate(${Math.atan2(dy,dx)}rad)`;
  board.appendChild(el);state.plankEls.set(p.id,el);
}
function removePlankById(id){
  const el=state.plankEls.get(id);if(el)el.remove();state.plankEls.delete(id);
  state.planks=state.planks.filter(p=>p.id!==id);
}
function plankBetween(a,b){
  return state.planks.find(p=>
    (p.r1===a.r&&p.c1===a.c&&p.r2===b.r&&p.c2===b.c)||(p.r1===b.r&&p.c1===b.c&&p.r2===a.r&&p.c2===a.c));
}
function isPole(p){
  if(!p)return false;
  if(state.start && isSame(p,state.start)) return true;
  if(state.goal  && isSame(p,state.goal))  return true;
  return state.poles.some(x=>x.r===p.r&&x.c===p.c);
}
function tryAddPlank(a,b){
  if(!isPole(a)||!isPole(b)){toast('Valitse kaksi tolppaa');return;}
  const dr=Math.abs(a.r-b.r),dc=Math.abs(a.c-b.c);
  if(dr&&dc){toast('Vain suora');return;}
  if(isBank(a.r)||isBank(b.r)){
    if(dc){toast('Rannalta pystysuora');return;}
    if(isBank(a.r)&&isBank(b.r)){toast('Ranta↔ranta ei');return;}
  }
  if(plankBetween(a,b)){toast('Span varattu');return;}
  // Ei välitolppia lankun alla
  const stepR = Math.sign(b.r - a.r), stepC = Math.sign(b.c - a.c);
  let rr = a.r + stepR, cc = a.c + stepC;
  while(!(rr===b.r && cc===b.c)){
    if(isPole({r:rr,c:cc})){ toast('Välissä tolppa'); return; }
    rr += stepR; cc += stepC;
  }
  // Ei risteyksiä/limityksiä muihin lankkuihin
  const cross = crossesExisting(a,b,state.planks);
  if(cross){ toast('Risteää/limittää olemassa olevan lankun'); return; }

  const p={r1:a.r,c1:a.c,r2:b.r,c2:b.c,id:'p'+uid++};state.planks.push(p);drawPlank(p);
}

/* ---------- Click handling ---------- */
board.addEventListener('click',e=>{
  const cell=e.target.closest('.cell');if(!cell)return;
  const r=+cell.dataset.r,c=+cell.dataset.c,p={r,c};
  if(mode==='pole')togglePole(r,c,cell);
  else if(mode==='start')setStart(r,c);
  else if(mode==='goal')setGoal(r,c);
  else if(mode==='plank'){
    if(!isPole(p)){toast('Valitse tolppa');return;}
    if(firstSel&&isSame(firstSel,p)){clearSel();return;}
    if(!firstSel){firstSel=p;cell.classList.add('selPole');}
    else{
      const a=firstSel,b=p;clearSel();
      const existing = plankBetween(a,b);
      if(existing){ removePlankById(existing.id); toast('Lankku poistettu'); }
      else { tryAddPlank(a,b); }
    }
  }
});

/* ---------- Clear ---------- */
clearBtn.onclick=()=>{document.querySelectorAll('.cell').forEach(c=>{
  c.classList.remove('pole','selPole');c.querySelectorAll('.badge').forEach(b=>b.remove());});
  state.plankEls.forEach(e=>e.remove());state.plankEls.clear();
  state.poles=[];state.planks=[];state.start=null;state.goal=null;firstSel=null;uid=1;
  currentIdx = -1; setStatus();
};

/* ---------- Storage helpers ---------- */
function getList(){ try{return JSON.parse(localStorage.getItem(LS_KEY)||'[]');}catch{return [];} }
function loadList(preserveSelection=true){
  const prev = preserveSelection ? puzzleSel.value : null;
  const arr = getList();
  puzzleSel.innerHTML='';
  arr.forEach((p,i)=>{
    const o=document.createElement('option');
    const s=p.start?`S(${p.start.r},${p.start.c})`:'S(-)';const g=p.goal?`G(${p.goal.r},${p.goal.c})`:'G(-)';
    o.value=i;o.textContent=`#${i+1} ${s} ${g} | planks:${(p.planks||[]).length}`;puzzleSel.appendChild(o);
  });
  if(prev!==null && Array.from(puzzleSel.options).some(o=>o.value===prev)) puzzleSel.value=prev;
  return arr;
}
function saveList(a){ localStorage.setItem(LS_KEY,JSON.stringify(a,null,2)); loadList(); }

/* ---------- Export whole list to JSON file ---------- */
saveBtn.onclick=()=>{
  const arr=getList();
  const blob=new Blob([JSON.stringify(arr,null,2)],{type:'application/json'});
  const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='puzzles_8x6.json';a.click();
  toast('Lista ladattu tiedostona',1500);
};

/* ---------- Export current puzzle object ---------- */
function currentPuzzle(){return{rows:ROWS,cols:COLS,start:state.start,goal:state.goal,
poles:state.poles.slice(),planks:state.planks.map(p=>[p.r1,p.c1,p.r2,p.c2])};}

/* ---------- Open selected ---------- */
openBtn.onclick=()=>{const idx=+puzzleSel.value; if(!(idx>=0)){toast('Ei valintaa');return;}
  const arr=getList(); if(!arr[idx]){toast('Valinta ei kelpaa');return;}
  loadPuzzle(arr[idx]); currentIdx = idx; setStatus(); toast(`Avattu #${idx+1}`);
};

/* ---------- Delete selected ---------- */
deleteBtn.onclick=()=>{
  const idx = +puzzleSel.value;
  if(!(idx>=0)){ toast('Ei valittua pulmaa.'); return; }
  const arr = getList();
  if(!arr[idx]){ toast('Valinta ei kelpaa.'); return; }
  arr.splice(idx,1);
  saveList(arr);
  clearBtn.onclick();
  if(arr.length>0){
    const nextIdx = Math.min(idx, arr.length-1);
    loadPuzzle(arr[nextIdx]);
    puzzleSel.value = String(nextIdx);
    currentIdx = nextIdx; setStatus();
    toast(`Poistettu. Avattu #${nextIdx+1}.`, 1800);
  }else{
    currentIdx = -1; setStatus();
    toast('Kaikki poistettu. Lista tyhjä.', 1600);
  }
};

/* ---------- Move / reorder ---------- */
moveUp.onclick=()=>{
  const idx=+puzzleSel.value; const arr=getList();
  if(!(idx>=0) || idx===0){ toast('Ei voi siirtää ylemmäs.'); return; }
  [arr[idx-1],arr[idx]]=[arr[idx],arr[idx-1]];
  saveList(arr);
  puzzleSel.value=String(idx-1);
  if(currentIdx===idx) currentIdx=idx-1;
  else if(currentIdx===idx-1) currentIdx=idx;
  setStatus();
  toast(`Siirretty #${idx+1} → #${idx}.`);
};

moveDown.onclick=()=>{
  const idx=+puzzleSel.value; const arr=getList();
  if(!(idx>=0) || idx===arr.length-1){ toast('Ei voi siirtää alemmas.'); return; }
  [arr[idx+1],arr[idx]]=[arr[idx],arr[idx+1]];
  saveList(arr);
  puzzleSel.value=String(idx+1);
  if(currentIdx===idx) currentIdx=idx+1;
  else if(currentIdx===idx+1) currentIdx=idx;
  setStatus();
  toast(`Siirretty #${idx+1} → #${idx+2}.`);
};

/* ---------- Save changes to selected ---------- */
saveChanges.onclick=()=>{
  const idx=+puzzleSel.value;
  if(!(idx>=0)){ toast('Valitse listalta pulma, johon tallennetaan.'); return; }
  const arr=getList();
  const p = currentPuzzle();
  arr[idx]=p;
  saveList(arr);
  currentIdx = idx; setStatus();
  toast(`Tallennettu muutokset kohtaan #${idx+1}`);
};

/* ---------- Save current as NEW ---------- */
saveNew.onclick=()=>{
  const arr=getList();
  const p=currentPuzzle();
  arr.push(p);
  saveList(arr);
  const newIdx=arr.length-1;
  puzzleSel.value=String(newIdx);
  currentIdx = newIdx; setStatus();
  toast(`Tallennettu uutena (#${newIdx+1})`);
};

/* ---------- Load a puzzle to board ---------- */
function loadPuzzle(p){
  clearBtn.onclick();
  if(p.start) setStart(p.start.r,p.start.c);
  if(p.goal)  setGoal(p.goal.r,p.goal.c);

  // SALLI TOLPAT MYÖS RANNOILLA (mutta älä laita tolppaa Start/Goal-soluun)
  (p.poles || []).forEach(({r,c}) => {
    const isStart = state.start && state.start.r === r && state.start.c === c;
    const isGoal  = state.goal  && state.goal.r  === r && state.goal.c  === c;
    if (!isStart && !isGoal) {
      state.poles.push({ r, c });
      getCell(r, c).classList.add('pole');
    }
  });

  (p.planks || []).forEach(a=>{
    const [r1,c1,r2,c2]=a;
    const obj={r1,c1,r2,c2,id:'p'+uid++};
    state.planks.push(obj);
    drawPlank(obj);
  });
}

/* ---------- File import replaces storage ---------- */
fileInput.onchange=async(e)=>{
  const f=e.target.files[0]; if(!f) return;
  try{
    const t=await f.text(); const data=JSON.parse(t); let replaced=[];
    if(Array.isArray(data)){
      replaced=data.filter(p=>(p&&p.rows===ROWS&&p.cols===COLS)||(p&&!p.rows&&!p.cols));
    }else if(typeof data==='object'&&data){
      if((data.rows===ROWS&&data.cols===COLS)||(!data.rows&&!data.cols)) replaced=[data];
    }else{ toast('Virheellinen JSON'); return; }
    localStorage.setItem(LS_KEY,JSON.stringify(replaced,null,2));
    loadList(false);
    clearBtn.onclick();
    if(replaced.length){
      loadPuzzle(replaced[0]); puzzleSel.value="0";
      currentIdx = 0; setStatus();
      toast(`Korvattu. Ladattu ${replaced.length} pulmaa ja avattu #1.`,2200);
    }else{
      currentIdx = -1; setStatus();
      toast('Korvattu, mutta ei pulmia.',2000);
    }
  }catch(err){ console.error(err); toast('Lataus epäonnistui'); }
};

/* ====================== SOLVER ====================== */
function lbl(r,c){ return labelForCell(r,c); }
function spanKey(r1,c1,r2,c2){
  const A=lbl(r1,c1),B=lbl(r2,c2); return (A<B)?`${A}|${B}`:`${B}|${A}`;
}
function spanText(r1,c1,r2,c2){
  const A=lbl(r1,c1),B=lbl(r2,c2); return (A<B)?`${A}${B}`:`${B}${A}`;
}
function allPoles(){
  const arr=[]; if(state.start) arr.push(state.start); if(state.goal) arr.push(state.goal);
  for(const p of state.poles) arr.push(p);
  const seen=new Set(), out=[];
  for(const p of arr){ const k=`${p.r},${p.c}`; if(!seen.has(k)){ seen.add(k); out.push(p); } }
  return out;
}
function hasPoleAt(r,c){
  if(state.start && state.start.r===r && state.start.c===c) return true;
  if(state.goal  && state.goal.r===r  && state.goal.c===c)  return true;
  return state.poles.some(p=>p.r===r && p.c===c);
}
function lineClear(a,b){
  const dr = Math.sign(b.r - a.r);
  const dc = Math.sign(b.c - a.c);
  let r = a.r + dr, c = a.c + dc;
  while(!(r===b.r && c===b.c)){
    if(hasPoleAt(r,c)) return false;
    r += dr; c += dc;
  }
  return true;
}
function shareEndpoint(a,b,p1,p2){
  const A=`${a.r},${a.c}`, B=`${b.r},${b.c}`;
  const P1=`${p1.r},${p1.c}`, P2=`${p2.r},${p2.c}`;
  return (A===P1||A===P2||B===P1||B===P2);
}
function overlapsCollinear(a,b,p1,p2){
  if(a.r===b.r && p1.r===p2.r && a.r===p1.r){
    const [x1,x2] = [Math.min(a.c,b.c), Math.max(a.c,b.c)];
    const [y1,y2] = [Math.min(p1.c,p2.c), Math.max(p1.c,p2.c)];
    const L = Math.max(0, Math.min(x2,y2) - Math.max(x1,y1));
    if(L>0) return true;
    if(Math.min(x2,y2) === Math.max(x1,y1)){
      const c = Math.min(x2,y2);
      const touch = ( (a.c===c && a.r===p1.r) || (b.c===c && b.r===p1.r) );
      return !touch ? true : false;
    }
    return false;
  }
  if(a.c===b.c && p1.c===p2.c && a.c===p1.c){
    const [x1,x2] = [Math.min(a.r,b.r), Math.max(a.r,b.r)];
    const [y1,y2] = [Math.min(p1.r,p2.r), Math.max(p1.r,p2.r)];
    const L = Math.max(0, Math.min(x2,y2) - Math.max(x1,y1));
    if(L>0) return true;
    if(Math.min(x2,y2) === Math.max(x1,y1)){
      const r = Math.min(x2,y2);
      const touch = ( (a.r===r && a.c===p1.c) || (b.r===r && b.c===p1.c) );
      return !touch ? true : false;
    }
    return false;
  }
  return false;
}
function crossOrthogonal(a,b,p1,p2){
  const isABH = (a.r===b.r), isP1V = (p1.c===p2.c);
  if(isABH && isP1V){
    const r = a.r, c = p1.c;
    const withinH = (c>=Math.min(a.c,b.c) && c<=Math.max(a.c,b.c));
    const withinV = (r>=Math.min(p1.r,p2.r) && r<=Math.max(p1.r,p2.r));
    if(withinH && withinV){
      const isEnd = ((a.r===r&&a.c===c)||(b.r===r&&b.c===c)||
                     (p1.r===r&&p1.c===c)||(p2.r===r&&p2.c===c));
      return isEnd ? false : true;
    }
    return false;
  }
  if(!isABH && !isP1V){ return crossOrthogonal(p1,p2,a,b); }
  return false;
}
function crossesExisting(a,b, others){
  for(const q of others){
    const p1 = {r:q.r1,c:q.c1}, p2 = {r:q.r2,c:q.r2}; // BUG guard, fixed below
  }
  return false;
}
// Correct cross-check using existing list
function crossesExisting(a,b, list){
  for(const q of list){
    const p1 = {r:q.r1,c:q.c1}, p2 = {r:q.r2,c:q.c2};
    if(shareEndpoint(a,b,p1,p2)) continue;
    if(overlapsCollinear(a,b,p1,p2)) return true;
    if(crossOrthogonal(a,b,p1,p2))  return true;
  }
  return false;
}

function validSpansOfLength(len, occupiedSet, otherPlanks){
  const P=allPoles(), spans=[];
  for(let i=0;i<P.length;i++){
    for(let j=i+1;j<P.length;j++){
      const a=P[i], b=P[j];
      const dr=Math.abs(a.r-b.r), dc=Math.abs(a.c-b.c);
      if(dr&&dc) continue;          // vain suorat
      if(dr+dc!==len) continue;     // pituus säilyy
      if(isBank(a.r)||isBank(b.r)){
        if(dc!==0) continue;        // rannalta pystysuora
        if(isBank(a.r)&&isBank(b.r)) continue; // bank↔bank ei
      }
      const key=spanKey(a.r,a.c,b.r,b.c);
      if(occupiedSet && occupiedSet.has(key)) continue;
      if(!lineClear(a,b)) continue; // ei välitolppia
      if(otherPlanks && crossesExisting(a,b, otherPlanks)) continue; // ei risteyksiä/limityksiä
      spans.push({a,b,key,txt:spanText(a.r,a.c,b.r,b.c)});
    }
  }
  return spans;
}
function buildAdj(planks){
  const adj=new Map();
  function add(u,v){ if(!adj.has(u)) adj.set(u,[]); adj.get(u).push(v); }
  for(const p of planks){
    const A=lbl(p.r1,p.c1), B=lbl(p.r2,p.c2);
    add(A,B); add(B,A);
  }
  return adj;
}
function reachableFrom(srcLabel, planks){
  const adj=buildAdj(planks), seen=new Set();
  if(!srcLabel) return seen;
  const q=[srcLabel]; seen.add(srcLabel);
  while(q.length){
    const x=q.shift();
    for(const y of (adj.get(x)||[])) if(!seen.has(y)){ seen.add(y); q.push(y); }
  }
  return seen;
}
function serializeState(planks, who){
  const keys=planks.map(p=>spanKey(p.r1,p.c1,p.r2,p.c2)).sort();
  return who+'#'+keys.join(',');
}
function solvePuzzle(){
  solveOut.textContent='…';
  if(!state.start||!state.goal){ solveOut.textContent='Aseta Start ja Goal rannoille.'; return; }

  const startLbl = lbl(state.start.r, state.start.c);
  const goalLbl  = lbl(state.goal.r,  state.goal.c);
  const initPlanks = state.planks.map(p=>({r1:p.r1,c1:p.c1,r2:p.r2,c2:p.c2}));
  const startKey = serializeState(initPlanks, startLbl);

  if(reachableFrom(startLbl, initPlanks).has(goalLbl)){
    solveOut.textContent='Jo valmiiksi ratkaistu (ei siirtoja).'; return;
  }

  const Q=[{planks:initPlanks, who:startLbl}];
  const seen=new Set([startKey]);
  const parent=new Map();
  const MAX_STATES=200000;

  while(Q.length){
    const {planks, who} = Q.shift();
    const curKey = serializeState(planks, who);

    if(reachableFrom(who, planks).has(goalLbl)){
      const seq=[]; let k=curKey;
      while(k!==startKey){ const p=parent.get(k); if(!p) break; seq.push(p.move); k=p.prev; }
      seq.reverse(); solveOut.textContent=seq.join('\n'); return;
    }

    const occupiedAll = new Set(planks.map(p=>spanKey(p.r1,p.c1,p.r2,p.c2)));
    const reachNow = reachableFrom(who, planks);

    for(let i=0;i<planks.length;i++){
      const p=planks[i];
      const A = lbl(p.r1,p.c1), B = lbl(p.r2,p.c2);
      const oldTxt = spanText(p.r1,p.c1,p.r2,p.c2).toLowerCase();

      const pickup = [];
      if(reachNow.has(A)) pickup.push(A);
      if(reachNow.has(B)) pickup.push(B);
      if(pickup.length===0) continue;

      const graphWithout = planks.filter((_,idx)=>idx!==i);
      const occMinus = new Set(occupiedAll); occMinus.delete(spanKey(p.r1,p.c1,p.r2,p.c2));
      const L = Math.abs(p.r1-p.r2)+Math.abs(p.c1-p.c2);

      const candSpans = validSpansOfLength(L, occMinus, graphWithout);

      for(const pickLbl of pickup){
        const reachCarry = reachableFrom(pickLbl, graphWithout);

        for(const cand of candSpans){
          const newA = lbl(cand.a.r,cand.a.c), newB = lbl(cand.b.r,cand.b.c);
          if(!reachCarry.has(newA) && !reachCarry.has(newB)) continue;

          const nxtPlanks = graphWithout.slice();
          nxtPlanks.splice(i, 0, {r1:cand.a.r,c1:cand.a.c,r2:cand.b.r,c2:cand.b.c});

          const nxtWho = reachCarry.has(newA) ? newA : newB;

          const nxtKey = serializeState(nxtPlanks, nxtWho);
          if(seen.has(nxtKey)) continue;
          seen.add(nxtKey);

          const moveTxt = `${oldTxt}-${cand.txt.toLowerCase()}`;
          parent.set(nxtKey, {prev:curKey, move:moveTxt});

          if(reachableFrom(nxtWho, nxtPlanks).has(goalLbl)){
            const seq=[moveTxt]; let k=curKey;
            while(k!==startKey){ const p=parent.get(k); if(!p) break; seq.push(p.move); k=p.prev; }
            seq.reverse(); solveOut.textContent=seq.join('\n'); return;
          }

          if(seen.size<MAX_STATES) Q.push({planks:nxtPlanks, who:nxtWho});
        }
      }
    }
  }
  solveOut.textContent='Ei ratkea: laillisia siirtoja kokeiltiin loppuun ilman reittiä.';
}

/* ===== Risti-/limitystarkistus (käytössä sekä lisäyksessä että solverin validSpansissa) ===== */
function crossesExisting(a,b, list){
  for(const q of list){
    const p1 = {r:q.r1,c:q.c1}, p2 = {r:q.r2,c:q.c2};
    if(shareEndpoint(a,b,p1,p2)) continue;
    if(overlapsCollinear(a,b,p1,p2)) return true;
    if(crossOrthogonal(a,b,p1,p2))  return true;
  }
  return false;
}

solveBtn.onclick=solvePuzzle;

/* ---------- Init ---------- */
loadList(false);
setStatus();
</script>
</body>
</html>
